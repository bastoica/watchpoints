#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <linux/fs.h>
#include <linux/hw_breakpoint.h>
#include <linux/slab.h>
#include <linux/list.h>
#include <linux/mm.h>
#include "watchpoints.h"
#include <linux/proc_fs.h>
#include <linux/miscdevice.h>
#include <linux/ptrace.h>
#include <asm/ptrace.h>
#include <asm/processor.h>
#include <asm/user_64.h>
#include <asm/elf.h>
#include <asm/debugreg.h>

MODULE_AUTHOR("Bogdan-Alexandru Stoica <bogdan.stoica@epfl.ch>");
MODULE_DESCRIPTION
    ("Set watchpoints from proc without going through ptrace");
MODULE_LICENSE("GPL");


/* on x86_64 there are only 4 watchpoints */
#define WATCHPOINTS_MAX (4)
#define MIN(a, b) ((a) < (b) ? (a) : (b))

/*
 * structs prototypes
 */

/* tracks changes */
struct values_list;

/* tracks pointers */
struct mem_loc_list;

/* tracks pids */
struct kmodule_context_list;


/*
 * Function prototypes
 */

 /* handles the opening of a pointer file */
static int proc_open(struct inode *inode, struct file *file);

/* handles the display of information on the pointer file */
static int proc_display(struct seq_file *m, void *v);

/* handles the watchpoint event */
static void
watchpoint_handler(struct perf_event *bp, struct perf_sample_data *data,
            struct pt_regs *regs);

/* handles the ioctl event */
static long
watchpoint_ioctl(struct file *file, unsigned int cmd,
            unsigned long user_msg);

/* initialization function for the module */
static int
__init watchpoint_init(void);

/* cleanup function for the module */
static void
__exit watchpoint_exit(void);

/* gets the head of the pointer list for the specified pid */
struct mem_loc_list
*get_mem_loc_entry(uint64_t addr);

/* initializes the watchpoint */
static struct perf_event
*initialize_watchpoint(wp_msg_t *wp, pid_t pid);

/* adds a new pointer to the list of pointers tracked by the pid */
static void
add_mem_loc_entry(struct perf_event *event, long size);

/* adds a new watchpoint */
static long
watchpoint_add(wp_msg_t *wp);

/* probe a watchpoint for memory accesses */
static long
watchpoint_poll(wp_msg_t *wp, uint64_t ubuff);

/* removes a watchpoint */
static long
watchpoint_remove(wp_msg_t *wp);

/* frees all changes recorded and returns the size used by the data */
static size_t
clean_tracked_changes_data(struct values_list *changes);

/* frees all pointers recorded and returns the size used by them */
static size_t
clean_tracked_pointer_data(struct mem_loc_list *pointers);

/* free all proc records and return the size used by them */
static int
clean_kmodule_context_data(void);

/*
 * Struct declarations
 */

/* representation of a change in data */
struct values_list {
  /* new value of the data */
  u8 *data;
  /* size of the data chunk */
  size_t data_size;
  /* list to which the data belongs */
  struct list_head head;
};

/* information about a pointer tracked by a watchpoint */
struct mem_loc_list {
  /* pointer tracked */
  struct perf_event *event;
  /* size of the pointer data area */
  size_t size;
  /* list to which the pointer belongs */
  struct list_head head;
  /* changes to the data to which the pointer points */
  struct values_list *values;
  /* PCs that access the memory location */
  hash_t pc_hash;
};

/* information about a pid tracked */
struct kmodule_context_list {
  /* pid tracked */
  pid_t pid;
  /* process /proc directory enter */
  struct proc_dir_entry *proc_entry;
  /* list of pointers to track for this pid */
  struct mem_loc_list *pointers;
  /* list to which the pointer belongs */
  struct list_head head;
};

typedef struct usr_msg_t {
  wp_msg_t wp;
  uint64_t ubuff;
} usr_msg_t;

/* file operations for the watchpoint entry in /dev */
const struct file_operations ctrl_fops = {
  .owner = THIS_MODULE,
  .read = NULL,
  .write = NULL,
  .unlocked_ioctl = watchpoint_ioctl,
  .open = NULL,
  .release = NULL,
};

/* informations about the watchpoint entry in /dev */
struct miscdevice watchpoints_misc = {
  .minor = MISC_DYNAMIC_MINOR,
  .name = DEVICE_NAME,
  .fops = &ctrl_fops
};

/* file operations for the pointer entries in /proc/watchpoints/pid */
const struct file_operations proc_fops = {
  .owner = THIS_MODULE,
  .open = proc_open,
  .read = seq_read,
  .llseek = seq_lseek,
  .release = single_release
};


/*
 * Globals declaration
 */

/* entry in the proc directory for the module */
struct proc_dir_entry *proc_watchpoints;

/* centralizes everything that is tracked by the module */
struct kmodule_context_list kmodule_context;

// TODO: Add #ifdef macros for debugging

/* register the initialization and cleanup functions */
module_init(watchpoint_init);
module_exit(watchpoint_exit);

static int proc_display(struct seq_file *m, void *v) {

  struct mem_loc_list *pointer = (struct mem_loc_list *) m->private;
  struct values_list *change;

  list_for_each_entry(change, &pointer->values->head, head) {
    long counter;
    seq_printf(m, "%lu ", change->data_size);
    for (counter = 0; counter < change->data_size; counter++) {
      seq_printf(m, "%c", change->data[counter]);
    }
  }

  return 0;
}

static int proc_open(struct inode *inode, struct file *file) {
  return single_open(file, proc_display, PDE_DATA(inode));
}

static struct kmodule_context_list *get_addr_for_pid(void) {

  // TODO: check return values + pr_debug("[kernel-space]: ... ");
  struct kmodule_context_list *proc;
  struct kmodule_context_list *iter;
  struct proc_dir_entry *pid_entry;
  struct mem_loc_list *pointers;
  uint8_t pid_name[30];

  list_for_each_entry(iter, &kmodule_context.head, head) {
    if (iter->pid == current->pid) {
      return iter;
    }
  }

  proc = kmalloc(sizeof(*proc), 0);
  pointers = kmalloc(sizeof(*pointers), 0);

  sprintf(pid_name, "%d", current->pid);
  pid_entry = proc_mkdir(pid_name, proc_watchpoints);
  proc->proc_entry = pid_entry;
  proc->pid = current->pid;
  proc->pointers = pointers;

  INIT_LIST_HEAD(&pointers->head);
  list_add_tail(&(proc->head), &kmodule_context.head);

  return proc;
}


static void
  add_mem_loc_entry(struct perf_event *event, long size) {

  // TODO: check return values + pr_debug("[kernel-space]: ... ");
  struct kmodule_context_list *tracked_pid;
  struct mem_loc_list *mem_loc;
  struct values_list *value;

  tracked_pid = NULL;
  tracked_pid = get_addr_for_pid();

  if (tracked_pid == NULL) {
    return;
  }

  if (get_mem_loc_entry((uint64_t)event->attr.bp_addr) != NULL) {
    pr_info("[kernel-space]: <0x%llx> not found.\n", (uint64_t)event->attr.bp_addr);
    return;
  }

  value = kmalloc(sizeof(*value), 0);

  mem_loc = kmalloc(sizeof(*mem_loc), 0);
  mem_loc->event = event;
  mem_loc->size = size;
  mem_loc->values = value;

  pr_info("[kernel-space]: Adding <0x%llx> with <%p>.\n",
    (uint64_t)event->attr.bp_addr, mem_loc);

  hasht_init(&mem_loc->pc_hash);
  INIT_LIST_HEAD(&value->head);

  list_add_tail(&(mem_loc->head), &tracked_pid->pointers->head);
}

struct mem_loc_list *get_mem_loc_entry(uint64_t addrs) {

  struct kmodule_context_list *tracked_pid;
  struct mem_loc_list *mem_loc;

  tracked_pid = get_addr_for_pid();
  if (tracked_pid == NULL) {
    // TODO: pr_debug("[kernel-space]: ... ");
    return NULL;
  }

  list_for_each_entry(mem_loc, &tracked_pid->pointers->head, head) {
    if (mem_loc->event->attr.bp_addr == addrs) {
      return mem_loc;
    }
  }

  // TODO: pr_debug("[kernel-space]: ... ");
  return NULL;
}


static void watchpoint_handler(struct perf_event *bp,
                     struct perf_sample_data *data,
                     struct pt_regs *regs) {

  struct mem_loc_list *pointer;
  struct task_struct *tsk;
  uint64_t pc = 0;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");

  pointer = get_mem_loc_entry(bp->attr.bp_addr);

  if (pointer == NULL) {
    pr_info("[kernel-space]: No watchpoint on address <0x%llx>.\n", (uint64_t)bp->attr.bp_addr);
    return;
  }

  tsk = pid_task(find_vpid(bp->ctx->task->pid), PIDTYPE_PID);
  pc = regs->ip;
  hasht_add(&pointer->pc_hash, pc);

  /*********** Record values ***********/
  // FIXME: We can run out of memory if there are many entries. There will be panic.

  // new_change = kmalloc(sizeof(*new_change), 0);
  // new_change->data = kmalloc((pointer->size + 1) * sizeof(u8), 0);
  // new_change->data[pointer->size] = '\0';

  // copy_from_user(new_change->data,
  //          (void *) pointer->event->attr.bp_addr,
  //          pointer->size);
  // new_change->data_size = pointer->size;
  // // list_add_tail(&(new_change->head), &pointer->values->head);

  // pr_info("[kernel-space]: Process %d accessed 0x%016llx from PC=0x%016llu, value: %s\n",
  //    bp->ctx->task->pid, pointer->event->attr.bp_addr, entry->pc, new_change->data);

  // kfree(new_change);

  return;
}

static struct perf_event*
  initialize_watchpoint(wp_msg_t *wp, pid_t pid) {

  struct perf_event *perf_watchpoint;
  struct task_struct *tsk;
  struct perf_event_attr attr;
  struct pt_regs *regs;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");

  /* Initialize watchpoint */
  hw_breakpoint_init(&attr);
  attr.bp_addr = wp->data_ptr;
  attr.bp_len = wp->data_size;
  attr.bp_type = HW_BREAKPOINT_RW;

  tsk = pid_task(find_vpid(pid), PIDTYPE_PID);
  regs = task_pt_regs(tsk);

  perf_watchpoint =
      register_user_hw_breakpoint(&attr, watchpoint_handler, NULL, tsk);

  return perf_watchpoint;
}

static long watchpoint_add(wp_msg_t *wp) {

  struct perf_event *perf_watchpoint;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");

  if (get_mem_loc_entry((uint64_t)wp->data_ptr) != NULL) {
    pr_info("[kernel-space]: Breakpoint already set on <0x%llx>\n", (uint64_t)wp->data_ptr);
    return 42;
  }

  perf_watchpoint = initialize_watchpoint(wp, current->pid);

  if (IS_ERR(perf_watchpoint)) {
    pr_info("[kernel-space]: [error]: Could not set watchpoint.\n");
    return 42;
  }

  add_mem_loc_entry(perf_watchpoint, wp->data_size);

  return 0;
}

static long watchpoint_poll(wp_msg_t *wp, uint64_t ubuff) {

  struct mem_loc_list *pointer;
  size_t memory_used = 0;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");

  pointer = get_mem_loc_entry((uint64_t)wp->data_ptr);
  if (pointer == NULL) {
    pr_info("[kernel-space]: [error]: No watchpoint on address 0x%llx.\n",
      (uint64_t)wp->data_ptr);
    return 42;
  }

  //hasht_copy_to_user(&pointer->pc_hash, (void __user *)msg->usr_buf);
  hasht_copy_to_user(&pointer->pc_hash, (void __user *)ubuff);
  memory_used = hasht_clear(&pointer->pc_hash);

  return 0;
}

static long watchpoint_remove(wp_msg_t *wp) {

  struct mem_loc_list *pointer;
  size_t memory_used = 0;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");

  pointer = get_mem_loc_entry((uint64_t)wp->data_ptr);
  if (pointer == NULL) {
    pr_info("[kernel-space]: [error]: No watchpoint on address 0x%llx.\n",
      (uint64_t)wp->data_ptr);
    return 42;
  }

  unregister_hw_breakpoint(pointer->event);


  memory_used += clean_tracked_changes_data(pointer->values);
  memory_used += hasht_clear(&pointer->pc_hash);
  memory_used += ksize(pointer);
  list_del(&pointer->head);
  kfree(pointer);

  return 0;
}

int no_wathcpoints = 0;
int no_clean_calls = 0;

static long watchpoint_ioctl(struct file *file, unsigned int cmd,
                unsigned long user_msg) {

  usr_msg_t usr;
  long ret_val;

  ret_val = copy_from_user(&usr, (void *)user_msg, sizeof(usr));
  if (ret_val != 0 && cmd != CLEAN_KMODULE) {
    pr_info("[kernel-space]: Cannot copy ioctl message from user (%llx, %d): %ld.\n",
      (uint64_t)(void *)user_msg, cmd, ret_val);
    return -EINVAL;
  }

  pr_info("[kernel-space]: cmd = %x, on <0x%llx> (size %u), no_bps = %d (cleanups=%d)\n",
     cmd, (uint64_t)usr.wp.data_ptr, usr.wp.data_size, no_wathcpoints, no_clean_calls);

  switch (cmd) {
    case ADD_WATCHPOINT:
      ret_val = watchpoint_add(&usr.wp);
      no_wathcpoints += (ret_val == 0);
      pr_info("[kernel-space] Done adding with outcome %d\n", (int)ret_val);
      break;
    case POLL_WATCHPOINT:
      ret_val = watchpoint_poll(&usr.wp, usr.ubuff);
      pr_info("[kernel-space] Done polling with outcome %d\n", (int)ret_val);
      break;
    case REMOVE_WATCHPOINT:
      ret_val = watchpoint_remove(&usr.wp);
      no_wathcpoints -= (ret_val == 0);
      pr_info("[kernel-space] Done removing with outcome %d\n", (int)ret_val);
      break;
    case CLEAN_KMODULE:
      ret_val = clean_kmodule_context_data();
      pr_info("[kernel-space] Done cleanup with outcome %d\n", (int)ret_val);
      no_wathcpoints = 0;
      no_clean_calls++;
      break;
    default:
      pr_debug("[kernel-space]: Watchpoints was sent an unknown command %d\n", cmd);
      ret_val = -EINVAL;
      break;
  }

  return ret_val;
}


static size_t clean_tracked_changes_data(struct values_list *values) {

  struct values_list *entry;
  struct values_list *temp;
  size_t memory_used = 0;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");

  list_for_each_entry_safe(entry, temp, &values->head, head) {

    memory_used += ksize(entry->data);
    kfree(entry->data);
    memory_used += ksize(entry);
    kfree(entry);
  }

  return memory_used;
}

static size_t clean_tracked_pointer_data(struct mem_loc_list *pointers) {

  struct mem_loc_list *pointer;
  struct mem_loc_list *temp;
  size_t memory_used = 0;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");

  if (pointers == NULL) {
    return memory_used;
  }

  list_for_each_entry_safe(pointer, temp, &pointers->head, head) {

    memory_used +=
          clean_tracked_changes_data(pointer->values);

    memory_used += hasht_clear(&pointer->pc_hash);

    memory_used += ksize(pointer);
    list_del(&pointer->head);
    kfree(pointer);
  }

  return memory_used;
}

static int clean_kmodule_context_data(void) {

  struct kmodule_context_list *pid_list;
  struct kmodule_context_list *temp;
  size_t memory_used = 0, per_pid = 0;

  // TODO: check return values + pr_debug("[kernel-space]: ... ");
  list_for_each_entry_safe(pid_list, temp, &kmodule_context.head, head) {
    uint8_t pid_name[30];

    per_pid =
        clean_tracked_pointer_data(pid_list->pointers);

    memory_used += per_pid;

    sprintf(pid_name, "%d", pid_list->pid);
    remove_proc_entry(pid_name, proc_watchpoints);

    memory_used += ksize(pid_list);
    list_del(&pid_list->head);
    kfree(pid_list);
  }
  pr_info("%lu bytes freed\n", memory_used);

  return 0;
}


static int __init watchpoint_init(void) {

  proc_watchpoints = proc_mkdir("watchpoints", NULL);
  INIT_LIST_HEAD(&kmodule_context.head);
  misc_register(&watchpoints_misc);
  pr_info("[kernel-space]: module successfully loaded\n");

  return 0;
}


static void __exit watchpoint_exit(void) {

  int rval = 0;

  rval = clean_kmodule_context_data();
  remove_proc_entry("watchpoints", NULL);
  misc_deregister(&watchpoints_misc);
  pr_info("[kernel-space]: module successfully unloaded\n");
}
